<html>


<!-- Mirrored from www25.brinkster.com by HTTrack Website Copier/3.x [XR,YP'2001] -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
<meta http-equiv="Content-Language" content="en-us">
<link href="../ManverusStyle.css" type=text/css rel=stylesheet>
<title>Totorials and Descriptions</title>
</head>

<body>
<div class="Section1">
  <p class="MsoTitle"><font size="5">Hex-Editing Guide by Vaskéz</font></p>
  <p class="MsoNormal"><b><font size="4">Intro (for beginners)<o:p>
  </o:p>
  </font></b><o:p>
  </o:p>
  </p>
  <p class="MsoNormal">Hex-editing, also called hexing is short for hexadecimal
  editing. It is so called because hex-editors display the data in a file in
  terms of hexadecimal numbers. What is the point in hexing? Well, it allows you
  to change any file almost in any way you wish. The drawback is that all you
  see is a bunch of numbers and letters so first you have to work out what each
  position in the file and the value in that position, represents.</p>
  <p class="MsoNormal">The position of a value in the file is known as the
  offset because its address is the number by which it is offset from the first
  position in the file. The first position always has an offset of 0 because it
  IS the start of the file so it is not offset from the start at all. And so the
  3<sup>rd</sup> value is at offset 2 (remember we start counting at 0).</p>
  <p class="MsoNormal">&nbsp;<o:p>
  </o:p>
  </p>
  <h1>The hexadecimal number system</h1>
  <p class="MsoNormal">A hex-editor displays the bits (binary digits, 1s and 0s)
  of a file in terms of hexadecimal numbers, as already mentioned. The reason
  for this is that even a relatively small number written in binary notation
  takes a lot of space to write. Hexadecimal (from now on referred to as hex)
  notation saves a lot of space when it comes to displaying the number because
  each hex digit represents 4 binary digits. I’ll explain why later.</p>
  <p class="MsoNormal">For those who don’t know how the hex number system
  works I will explain here.</p>
  <p class="MsoNormal">First of all it is important to know that there are 2
  ways of indicating that a number is written in hex notation. You can use
  ‘0x’ at the beginning of the number or an ‘H’ (or ‘h’) at the end.
  For example:</p>
  <p class="MsoNormal">0x8</p>
  <p class="MsoNormal">and</p>
  <p class="MsoNormal">8H</p>
  <p class="MsoNormal">both represent a decimal 8 in hex notation. In case you
  don’t know, decimal is the ‘normal’ number system we use, with the
  digits 0,1,2,3,4,5,6,7,8,9. So called because deci means ten and the decimal
  number system has ten different digits.</p>
  <p class="MsoNormal">Similarly, the hexadecimal number system is so called
  because it has 16 different digits:</p>
  <p class="MsoNormal">0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F, where A=10 (in decimal),
  B=11, C=12, D=13, E=14 and F=15.</p>
  <p class="MsoNormal">To understand how to convert from decimal to hex and
  vice-versa, it is better to think about the way the decimal system works,
  first.</p>
  <p class="MsoNormal">In decimal, each <i>position</i> in the number is worth
  ten times the one to its right. Therefore ten is known as the <i>base</i> of
  the decimal number system. Similarly, sixteen is the base of the hexadecimal
  number system, because each position is worth sixteen times the one to its
  right. This is true for any number system: as you move right to left, each
  position is worth the base of the number system times the position to its
  right. In binary, the base is 2 and each position is worth 2 times the one to
  its right.</p>
  <p class="MsoNormal">To get the final value of a number in any number system
  you multiply the value in the position with the value of the position and add
  all the values up. For example:<o:p>
  </o:p>
  </p>
  <p class="MsoNormal">Take, in decimal: 1111 (one thousand one hundred and
  eleven). The right-most position is worth 1 because it is 10 to the power of 0
  (10<sup>0</sup>). The second position is worth 10 which is 10<sup>1</sup> and
  the third from the right is worth 100 (10<sup>2</sup>), while the last
  position is worth 1000 (10<sup>3</sup>). And each position is multiplied by
  the value in the position to give the number. 1111 is equal to 1*10<sup>0</sup>
  + 1*10<sup>1</sup> + 1*10<sup>2</sup> + 1 *10<sup>3</sup> which equals 1 + 10
  + 100 + 1000 = 1111. Simple as that. Except we don’t normally think about it
  in so much detail.</p>
  <p class="MsoNormal">Similarly, 1234 is 4*10<sup>0</sup> + 3*10<sup>1</sup> +
  2*10<sup>2</sup> + 1 *10<sup>3</sup> which equals 4 + 30 + 200 + 1000 = 1234
  (one thousand two hundred and thirty-four).</p>
  <p class="MsoNormal">The general rule is: Each position is worth the base of
  the number system, raised to the power of its number in the sequence counting
  along from the right, starting at 0. In decimal the position of the ‘3’ in
  3000000 is worth 10<sup>6</sup> because the base is 10 and the position of the
  3 from the right is 6 because we start counting at 0.<o:p>
  </o:p>
  </p>
  <p class="MsoNormal">The reason I went through all that is to make it easy to
  understand the hexadecimal system. Remember the general rules, each position
  is worth the base times the number of the position counting from the right,
  starting at 0 and the value of the number overall is the sum of the values in
  each position multiplied by the value of the position. So in hexadecimal:</p>
  <p class="MsoNormal">0x1111 is worth (starting on the right remember):</p>
  <p class="MsoNormal">1*16<sup>0</sup> + 1*16<sup>1</sup> + 1*16<sup>2</sup> +
  1*16<sup>3</sup> which equals 1 + 16 + 256 + 4096 = 4369 (in decimal, in
  general, when there is no symbol next to the number, it is in decimal
  notation).</p>
  <p class="MsoNormal">One more example, using the ‘extra’ digits in hex:</p>
  <p class="MsoNormal">0xABCD is worth:</p>
  <p class="MsoNormal">13*16<sup>0</sup> + 12*16<sup>1</sup> + 11*16<sup>2</sup>
  + 10*16<sup>3</sup> = 13 + 192 + 2816 + 40960 = 43981.</p>
  <p class="MsoNormal">As you can see, even against decimal, we save one digit
  because the number 43981 is given by 5 digits but its equivalent, 0xABCD is
  only 4 digits.<o:p>
  </o:p>
  </p>
  <p class="MsoNormal">Now, as I said, hex notation is used to display the 1s
  and 0s of a file. In binary, the number 43981 would be 1010101111001101B (B
  means binary, not to be confused with the B in hex notation which means 11,
  hehe). As you can see this takes up 16 digits as opposed to the 4 used in the
  hex notation. The reason for this is that 2<sup>4</sup> = 16. The base of the
  binary system is 2 and the base of the hex system is 16. So hex saves space.<o:p>
  </o:p>
  </p>
  <h1>The Hex-Editor Display</h1>
  <p class="MsoNormal"><u>&nbsp;<o:p>
  </o:p>
  </u></p>
  <p class="MsoNormal">The basic function of most hex-editors is the same. On
  the left are the hex offsets of the start of each row of 16 bytes. In the
  middle is the big block of hexadecimal values representing the file. The
  values are in pairs as you should be able to see. This is because (it is
  common knowledge) that there are 8 bits in a byte. And remember, each hex
  digit represents 4 bits (binary digits). Therefore 2 hex digits represent 8
  bits, in other words, 1 byte. So the hex numbers are displayed as single bytes
  in a hex editor, for convenience. The offset is also measured as the number of
  bytes up to that point. For example, at offset 0x20, you will find the 33<sup>rd</sup>
  byte (remember, start at 0) because 0x20 equals 32 in decimal.</p>
  <p class="MsoNormal">On the right of the display, you should find a section
  where there are actually readable strings. This section is like a text-editor.
  You may have heard of the ASCII table, which shows the decimal and hexadecimal
  codes for each character on the keyboard. On the right, you will find the
  ASCII character representation for each byte in the file. One byte represents
  one character. Of course, often, the characters will be meaningless because
  the data in that position is not meant to be text data. However, if you <i>can
  </i>read it, it is most likely to be text data. Most hex-editors let you type
  normally in this text section and will automatically insert the hex values
  corresponding to the characters you typed in, in the hex section. Of course,
  if you have an ASCII table handy you could type the hexadecimal number into
  the hex area and watch the characters appear (if you are crazy and have
  nothing better to do).<o:p>
  </o:p>
  </p>
  <h1>Hex-Editing the Infinity Engine Files<o:p>
  </o:p>
  </h1>
  <p class="MsoNormal">Having read the previous section, you will understood
  that references to file names such as in the “resource key” for a spell
  effect, will be readable as normal text in a hex editor, and you can edit them
  just as easily as if you were using IEEP. Of course numbers must be converted
  to hexadecimal (use a calculator for big numbers) and entered in the hex
  section in the editor. DO NOT try and type decimal numbers into the text area
  using your numpad because this will just enter the ASCII code for the number
  characters into the hex area.</p>
  <br>
  <img src="hex01.jpg" v:shapes="_x0000_i1025" width="564" height="359"><br>
  <p class="MsoNormal">As you can see from the above picture, the hex offset at
  the start of each column is shown on the left. The main hexing area is in the
  middle and the ASCII text area is on the right. The file being edited here is
  the .spl file for the wizard spell “Monster Summoning II” from BG2. As you
  can see, at offset 00000010h (10h), there is the reference for the spell
  completion sound. You can see the values 43 41 53 5F 4D 30 33 00 which
  represent the ASCII characters CAS_M03, shown on the left. You can also type
  in those characters if you click on the text area and the hex values will
  appear.</p>
  <p class="MsoNormal">One thing to note for hex-editing IE files: The general
  rule for ANY number system is that the least significant digit (worth the
  least) is always on the right, as I have shown in earlier sections. However,
  the numbers in IE files seem to be written in little-endian format which means
  that the least significant digit is written in the lowest address (offset).
  Which means that the number 43981 would not be written AB CD, rather, CD AB.
  The values retain their order within the bytes but the actual order of the
  bytes is swapped around. This complicates things a little but if you remember
  this it shouldn’t be too much of a problem. This is most useful to know when
  you want your item or spell or creature to have the same name as an existing
  thing in the game but you don’t want to create a whole new entry in the
  dialog.tlk file. In this case, you can hex-edit the file and enter in the
  string reference number to the text that you want. This will be entered in
  little-endian format as shown above. I have not investigated this thoroughly,
  but it seems to be the case wherever I have looked.</p>
  <p class="MsoNormal">&nbsp;<o:p>
  </o:p>
  </p>
  <p class="MsoNormal">As an example, let’s say that you want your spell to be
  called “Shapeshifts Natural Form” because you need your own version that
  has a few different effects to the standard one. You might want to make 10 of
  these for example, for each shapeshift spell you have. You do not want 10
  extra entries in dialog.tlk all saying the same thing. Instead you can
  hex-edit the files to all point at the one existing string that says what you
  want.</p>
  <p class="MsoNormal">In BG2 this string is at reference 11826. This is 0x2E32.
  So you would go to offset 0x8 and the IEFFHP website will also tell you that
  this field is 4 bytes long. You would type in 32 2E 00 00 because it is in
  little-endian format and is 4 bytes (32 bits) long. If you now load up the
  spell in IEEP, the spell name should be Shapeshifts Natural Form.</p>
  <p class="MsoNormal">&nbsp;<o:p>
  </o:p>
  </p>
  <h1>Links and contact information</h1>
  <p class="MsoNormal">This guide was meant as an introduction to hex-editing
  and not as an exhaustive how-to. If you have any further questions, or notice
  any errors in this document, please email me, <a href="mailto:don_vaskez@freemail.hu">the
  author</a>. You can also leave a message in my guest book on <a href="http://www27.brinkster.com/vaskez/" target="_blank">my
  site</a>. if you just want to comment generally, or give suggestions as to how
  this guide can be improved. Then others will see your idea and it will not get
  repeated again and again.<o:p>
  </o:p>
  </p>
  <p class="MsoNormal">Vaskéz</p>
</div>
<p align="center"><font size="6">Hex Glossary</font></p>
<table border="1" width="610">
  <tr>
    <td width="28%">History :</td>
    <td width="72%">File done by TeamBG</td>
  </tr>
  <tr>
    <td width="28%">&nbsp;</td>
    <td width="72%">Modified by Manveru (25.10.2001)</td>
  </tr>
</table>
<p><font color="#660000">HEXADECIMAL</font>- Base 16 numbers. This means values
are counted in groups of 16, as opposed to groups of 10 as we are accustomed to.</p>
<p>These are the numbers : 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F</p>
<p>so for example 10h=16d</p>
<p>&nbsp;An easy primer on counting in hex may be found at:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td onMouseover="this.style.backgroundColor='000000';"
 onMouseout="this.style.backgroundColor='F6F7EB'">
<p>
<a href="http://www.tcaep.co.uk/maths/numbers/basen/index.htm">http://www.tcaep.co.uk/maths/numbers/basen/index.htm</a></p>
    </td>
  </tr>
</table>
<p>
An advanced text on assembly language may be found at:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<table border="1" width="100%">
  <tr>
    <td onMouseover="this.style.backgroundColor='000000';"
 onMouseout="this.style.backgroundColor='F6F7EB'">
<p>
<a href="http://webster.cs.ucr.edu/Page_asm/ArtofAssembly/ArtofAsm.html">http://webster.cs.ucr.edu/Page_asm/ArtofAssembly/ArtofAsm.html</a></p>
    </td>
  </tr>
</table>
<p>
It is strongly advised that you read at least the first two chapters at the
above site. If it is too complex for you, hex editing will be difficult to
understand fully<br>
Hex numbers should be expressed like this: &quot;0x04A&quot; or &quot;4Ah&quot;
when discussing them at the hex board<br>
Express decimal numbers as &quot;d10&quot; or &quot;d52&quot;</p>
<p><font color="#660000">BITMASK (aka BITFLAG)</font>- Method of stretching the amount of
information a single byte can contain. This works because of the corellation
between binary and hex. Multiple fields can be switched &quot;on&quot; or
&quot;off&quot; using this. It works like this:<br>
&nbsp;<center>
<table border="1" cols="9" width="60%">
  <tbody>
    <tr>
      <td><font size="-1">BIT</font></td>
      <td>8</td>
      <td>7</td>
      <td>6</td>
      <td>5</td>
      <td>4</td>
      <td>3</td>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <td><font size="-1">Value</font><br>
        <font size="-1">0n/Off</font></td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td><font size="-1">Dec. Value</font></td>
      <td>128</td>
      <td>64</td>
      <td>32</td>
      <td>16</td>
      <td>8</td>
      <td>4</td>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <td>170=</td>
      <td>128</td>
      <td>+0</td>
      <td>+32</td>
      <td>+0</td>
      <td>+8</td>
      <td>+0</td>
      <td>+2</td>
      <td>+0</td>
    </tr>
  </tbody>
</table>
</center>&nbsp;
<p>Binary: 10101010 equals 170 decimal which equals&nbsp; Hex: AA<br>
If the information was being stored in binary, it would take four bytes to
represent the same number represented by one in hex.<br>
In the first example, data field eight is &quot;on&quot;- 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
field seven is &quot;off&quot;- 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
field six is &quot;on&quot;- 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
and so on....<br>
Now, if we want to turn &quot;on&quot; field seven, the binary is now: 11101010
adding 64 (value of 7th bit) to the decimal value for a total of 234. Converting
the decimal value of 234 to Hex you get: EA<br>
One byte does the work of many this way to allow a single offset to control
different attributes- for example, item usability (note: this is an example, and
not how the true usability chart looks)<center></p>
<table border="1" cols="9" width="75%">
  <tbody>
    <tr>
      <td>BIT</td>
      <td>8</td>
      <td>7</td>
      <td>6</td>
      <td>5</td>
      <td>4</td>
      <td>3</td>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <td>CLASS</td>
      <td>mage</td>
      <td>cleric</td>
      <td>fighter</td>
      <td>thief</td>
      <td>ranger</td>
      <td>paladin</td>
      <td>bard</td>
      <td>druid</td>
    </tr>
    <tr>
      <td>VALUE</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>USABLE</td>
      <td>yes</td>
      <td>no</td>
      <td>yes</td>
      <td>no</td>
      <td>yes</td>
      <td>no</td>
      <td>yes</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</center>The item is usable by mage, fighter, ranger, and bard. If bit seven is
set to &quot;1&quot;, the item will also be usable by clerics.
<p><font color="#660000">OFFSET</font>- the location of a specific byte, usually
given in hexadecimal- the 85th (decimal) byte is offset 0x055h<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#990000">GLOBAL OFFSET</font><font color="#000000">- the offset's
location in the whole file</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#990000">LOCAL OFFSET</font><font color="#000000">- the offset's
location within a section of the file, such as in a feature block</font>
<p><font color="#660000">BYTE</font>- unit of eight bits in binary, represented
in hex as two digits or letters, such as &quot;02&quot;, &quot;5A&quot;, or
&quot;CB&quot;
<p><font color="#660000">BIT</font>- smallest unit of binary numbers-
&quot;0&quot; (off) or &quot;1&quot; (on)
<p><font color="#660000">HEADER</font>- in items, the first d114 bytes of the
file, which establishes general properties of the item, such as usability, most
icons, item avatar (image), or type. Contains counts of how many feature blocks
affect the user of the item and how many extended headers are present in the
file
<p><font color="#660000">EXTENDED HEADER</font>- an additional section of d56
bytes following the header that establishes more specific properties, such as
attack type, equipped icon, some ranged graphic effects, and a count of how many
feature blocks are used by the extended header. Multiple extended headers may be
used in an item to generate a wide range of abilities
<p><font color="#660000">FEATURE BLOCK</font>- sections of the file d48 bytes in
length that detail specific properties or effects that an item posesses. Also
called &quot;<font color="#660000">structs</font>&quot;. See the Mailing List
for details.
<p><font color="#660000">LITTLE-ENDIAN</font>- a method of expressing numbers
with multiple place values, not as complex as it sounds:<br>
If we were to say &quot; <font color="#ff0000">one million</font>, <font color="#3366ff">four
hundred twenty-five thousand</font>, <font color="#009900">eight hundred and
sixty-two</font> dollars&quot;, we would write this:<br>
&quot;$ <font color="#ff0000">1</font>, <font color="#3366ff">425</font>, <font color="#00cc00">862</font>&quot;.
That is big- endian. To express that amount of money in little- endian, we would
write &quot;$ <font color="#00cc00">862</font>, <font color="#3366ff">425</font>,
<font color="#ff0000">1</font>&quot;<br>
The amount of money is unchanged, but we express from left to right, smallest
value to highest value, instead of&nbsp; left to right, highest to lowest as is
done for common usage.&nbsp;<br>
So damage type &quot;00 00 00 01&quot; would be written in little- endian as
&quot;01 00 00 00&quot;
<p><font color="#660000">DATA TYPES</font><font color="#000000">- some common
data types referred to, and what they mean-</font>
<p><center>
<table border="1" cols="4" width="472">
  <tbody>
    <tr>
      <td width="123">TYPE</td>
      <td width="161">EXAMPLE</td>
      <td width="89">SYNONYMS</td>
      <td width="71">LENGTH</td>
    </tr>
    <tr>
      <td width="123">BYTE</td>
      <td width="161">0A</td>
      <td width="89">&nbsp;</td>
      <td width="71">1 BYTE</td>
    </tr>
    <tr>
      <td width="123">WORD</td>
      <td width="161">0AC1</td>
      <td width="89"><font color="#000000">&nbsp;INTEGER,&nbsp;&nbsp; INT</font></td>
      <td width="71">2 BYTES</td>
    </tr>
    <tr>
      <td width="123">DOUBLE WORD</td>
      <td width="161">0AC1 11F3</td>
      <td width="89"><font color="#000000">DWORD, LONG INTEGER, LONG INT, LONG</font></td>
      <td width="71">4 BYTES</td>
    </tr>
    <tr>
      <td width="123">String (Eg. resref)</td>
      <td width="161">4D61 6E76 6572 7554</td>
      <td width="89">Char Array</td>
      <td width="71">8 BYTES</td>
    </tr>
  </tbody>
</table>
</center>

<p>&nbsp;</p>

</body>


<!-- Mirrored from www25.brinkster.com by HTTrack Website Copier/3.x [XR,YP'2001] -->
</html>
